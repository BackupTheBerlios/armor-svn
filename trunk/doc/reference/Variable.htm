<html>
<HEAD>
<LINK REL=StyleSheet HREF="../style.css" TYPE="text/css">
<LINK REL=StyleSheet HREF="style-print.css" TYPE="text/css" MEDIA=print></LINK>
</HEAD>

<BODY>
<h1>Attribute Descriptors</h1>
<index name="attributes">
<index name="attribute types">

<P>Attribute descriptors are stored in objects derived from type
<CODE>orange.Variable</CODE>. Their role is to identify the
attributes. Two attributes in Orange are same, if they have the
same descriptor, not the same name. Besides, descriptors store
symbolic names for attributes and their symbolic values. Another
important feature of <CODE>orange.Variable</CODE> is that define
a method by which an attribute value can be computed from other
attributes; this is used in, for instance, discretization.</P>

<H2>Variable</H2>

<P><CODE>orange.<INDEX name="classes/Variable">Variable</CODE> is a base class for attribute descriptors.</P>

<p class=section>Attributes</P>

<DL class=attributes>
<DT>name</DT>
<DD>
Each attribute has a name. An empty string is a wholly legal name
that can and should be used for temporary or very internal
attributes. Two attributes can have the same name: Orange does
not distinguish attributes by names except in communication with
user (when user wants to see a value of attribute 'age', the name
is obviously used) or when loading the data (see the explanation
in <A href="fileformats.htm">Supported File Formats</A>).
However, if two attributes with same names appear in the same
domain and indexing by names is used, results of user queries are
unpredictable. In general, try to avoid giving the same name to
different attributes.<DD>

<DT>varType</DT>
<DD><CODE>varType</CODE> is an integer describing the attribute
type. As for <CODE>orange.Value</CODE>'s <CODE>varType</CODE>, it
can be <code>orange.VarTypes.Discrete</code> (1),
<code>orange.VarTypes.Continuous</code> (2) or
<code>orange.VarTypes.Other</code>.</DD>

<DT>getValueFrom</DT>
<DD>When attribute is derived from other attributes, e.g. through
discretization, binarization or some form of constructive
induction, <CODE>getValueFrom</CODE> points to a "function" that
computes the value of the attribute from values of other
attributes. The function is actually an
<CODE>orange.Classifier</CODE>: its input is an
<CODE>orange.Example</CODE> whose values are used to compute the
value of the derived attribute, and its result is the computed
value. A great thing about this is that it usually happens behind
your back. Even more, you should <B>never call
<CODE>getValueFrom</CODE> directly, but should do so through
method <CODE>computeValue</CODE> that establishes security
measures prohibiting deadlocks.</B></P>

<P>Although <CODE>getValueFrom</CODE> is always of type
<CODE>orange.Classifier</CODE>, you can set it to an ordinary
Python function or callable class. Orange will automatically wrap
it into an <CODE>orange.Classifier</CODE>, as described in <A
href="callbacks.htm">Subtyping Orange classes in Python</A>.</P>

<P>See the corresponding example below.</P></DD>

<DT>ordered</DT>
<DD>A flag telling whether the attribute values are ordered. At
the moment, no method actually treats ordinal attributes
differently than nominal, so this flag is reserved for future
use.</DD>

<DT>distributed</DT>
<DD>A flag that tells whether the values of this attribute are distributions. As for flag <CODE>ordered</CODE>, no methods treat such attributes in any special manner, so the flag is again reserved for future use.</DD>

<DT>sourceVariable</DT>
<DD>Another attribute for potential use in future: if
<CODE>getValueFrom</CODE> computes the attribute value from a
single attribute, this attribute can be (but is not necessarily)
stored in <CODE>sourceVariable</CODE>. As this is only used in a
rather obscure place you won't run into, there's no harm in not
ever setting <CODE>sourceVariable</CODE>.</DD>
</DT>

<DT>randomGenerator</DT>
<DD>Local random number generator used by method <CODE>randomValue</CODE>.</DD>
</DL>

<p class=section>Methods</P>

<DL class=attributes>
<DT>&lt;constructors&gt;</DT>
<DD>Constructors for classes derived from
<CODE>orange.Variable</CODE> (which is abstract itself) can be
given the usual keyword arguments. Besides, the attribute name
can be given directly. That is, an attribute descriptor for
continuous attribute "age" can be constructed by calling
<CODE>orange.FloatVariable("age")</CODE> or, equivalently, by
<CODE>orange.FloatVariable(name="age")</CODE>.</DD>

<DT>&lt;call&gt;</DT>
<DD>Calling a descriptor can be used to convert symbolic, integer
or any other applicable native Python types into
<CODE>orange.Value</CODE> objects for this attribute. Calling
<CODE>var(val)</CODE> is equivalent to <CODE>orange.Value(var,
val)</CODE>; see <A href="value.htm#construction">construction of
values</A>.</DD>

<DT>&lt;iteration&gt;</DT>
<DD>Attribute descriptors can be used in <CODE>for</CODE> loops.
So <CODE>for val in var</CODE> would iterate through all values
of attribute <CODE>var</CODE>, when possible.</DD>

<DT>randomValue()</DT>
<DD><CODE>randomValue</CODE> returns a random value for the attribute, when possible. This function uses <CODE>randomGenerator</CODE>; if none has been assigned yet, a new is constructed with the initial seed 0, and stored for the future use.</DD>

<DT>computeValue(example)</DT>
<DD>Calls <CODE>getValueFrom</CODE> through a mechanism that prevents deadlocks by circular calls.</DD>
</DL>

<A name="EnumVariable"></A>
<H2>EnumVariable</H2>

<P><CODE><INDEX name="classes/EnumVariable">EnumVariable</CODE> is a descriptor for nominal and
ordinal attributes. It defines two additional attributes,
<CODE>values</CODE> and <CODE>baseValue</CODE>, and no additional
methods. Iterating and returning random values is supported.

<p class=section>Attributes</p>

<DL class=attributes>
<DT>values</DT>
<DD>A list with symbolic names for attribute's values. Values for
attributes of type <CODE>EnumVariable</CODE> are stored as
integers referring to this list. Therefore, modifying this list
instantly changes names of values of examples, as they are
printed out or referred to by user. The size of the list is also
used to indicate the number of possible values for this
attribute; changing the size, especially <B>shrinking the list
can have disastrous effects and is therefore not really
recommendable</B>. You've been warned.</P>

<P>It is also assumed that <CODE>values</CODE> is always defined
(but can be empty), so you should never set <CODE>values</CODE>
to <CODE>None</CODE>.</dd>

<DT>baseValue</DT>
<DD>Sets the base value for the attribute. This can be, for
instance a "normal" value, such as "no complications" as opposed
to abnormal "low blood pressure" and "excessive blooding". The
base value can be (and is) used by certain statistics and,
potentially, learning algorithms. <CODE>baseValue</CODE> is an
integer that is to be interpreted as an index to
<CODE>values</CODE>. The absence of base value ("sex" can be
either "female" or "male", without an obvious base value) is
indicated by <CODE>-1</CODE>.</DD> </DL>

<A name="FloatVariable">
<H2>FloatVariable</H2>


<P><CODE><INDEX name="classes/FloatVariable">FloatVariable</CODE> is a descriptor for continuous
attributes.

<DL class=attributes>
<DT>startValue, endValue, stepValue</DT>
<DD>The range of attribute, used for returning random values and for iteration. You can leave
the three values at defaults (<CODE>-1</CODE>, which is
interpreted as undefined), if you don't need randoms and
iterations. (I can't recall ever using them...)</DD>

<DT>numberOfDecimals</DT>
<DD>The number of decimals used when the value is printed, converted to a string or saved to a file</DD>

<DT>scientificFormat</DT>
<DD>If <CODE>True</CODE>, the value is printed in scientific format whenever it would have more than 5 digits. In this case, <CODE>numberOfDecimals</CODE> is ignored.</DD>

<DT>adjustDecimals</DT>
<DD>Tells Orange to monitor the number of decimals when the value is converted from a string (either by setting the attribute values, <I>e.g.</I> <CODE>example[0]="3.14"</CODE> or when reading from file). The value of 0 means that the number of decimals should not be adjusted, while 1 and 2 mean that adjustments are on, with 2 denoting that no values have been converted yet.</DD>
</DL>

<P>By default, adjustment of number of decimals goes as follows. If the attribute was constructed when examples were read from a file, it will be printed with the same number of decimals as the largest number of decimals encountered in the file. If scientific notation occurs in the file, <CODE>scientificFormat</CODE> will be set to True and scientific format will be used for values too large or too small.</P>

<P>If the attribute is created in a script, it will have, by default, three decimals places. This can be changed either by setting the attribute value from a string (<I>e.g.</I> <CODE>example[0]="3.14"</CODE>, but not <CODE>example[0]=3.14</CODE>) or by manually setting the <CODE>numberOfDecimals</CODE> (<I>e.g.</I> <CODE>attr.numberOfDecimals=1</CODE>).</P>

<A name="StringVariable">
<H2>StringVariable</H2>

<P><CODE><INDEX name="classes/StringVariable">StringVariable</CODE> describes attributes that contains
strings. No method can use them for learning; some will complain
and other will silently ignore them when the encounter them. They
can be, however, useful for meta-attributes; if examples in
dataset have unique id's, the most efficient way to retain them
is to read them as meta-attributes. In general, never use
discrete attributes with many (say, more than 50) values. Such
attributes are probably not of any use for learning and should be
stored as string attributes.</P>

<P>There's a short and simple example which makes use of
<CODE>StringVariable</CODE> near the end of the page about <a
href="Domain.htm"><CODE>Domain</CODE></A>.</P>

<P>When converting strings into values and back, empty strings are treated differently than usual. For other types, an empty string can be used as a synonymous for question mark ("don't know"), while <code>StringVariable</code> will take empty string as an empty string -- that is, except when loading or saving into file. Empty strings in files are interpreted as "don't know". You can, however, enclose the string into double quotes; these get removed when the string is loaded. Therefore, to give an empty string, put it into double quotes, <code>""</code>.</P>


<H2>PythonVariable</H2>

<P><CODE><INDEX name="classes/PythonVariable">PythonVariable</CODE> is a base class for descriptors defined in Python. Itself fully functional, <CODE>PythonVariable</CODE> can already be used as a descriptor for attributes that contain arbitrary Python values. Since this is an advanced topic, <CODE>PythonVariable</CODE>s are described on a <A href="PythonVariable.htm">a separate page</A>.

<A name="getValueFrom">
<H2>Using getValueFrom</H2>

<P>Monk 1 is a well-known dataset with target concept <CODE>y :=
a==b or e==1</CODE>. It does not hurt, even more, it can even
help if we replace the four-valued attribute <CODE>e</CODE> with
a binary attribute having values <CODE>1</CODE> and <CODE>not
1</CODE>. The new attribute shall be computed from the old one on
the fly.</P>

<p class="header">part of <a href="variable.py">variable.py</a>
(uses <a href="monk1.tab">monk1.tab</a>)</p>
<XMP class="code">import orange
data = orange.ExampleTable("monk1")

e2 = orange.EnumVariable("e2", values = ["not 1", "1"])

def checkE(example, returnWhat):
    if example["e"]=="1":
        return orange.Value(e2, "1")
    else:
        return orange.Value(e2, "not 1")

e2.getValueFrom = checkE
</XMP>
</P>

<P>Our new attribute is named <CODE>e2</CODE>; we define it by
descriptor of type <CODE>orange.EnumVariable</CODE>, with
appropriate name and values <CODE>not 1</CODE> and <CODE>1</CODE> (we chose this order so that the <CODE>not 1</CODE>'s index is 0, which can be, if needed, interpreted as <CODE>false</CODE>).</P>

<P><CODE>checkE</CODE> is a function that is passed an example
and another argument we don't care about. If example's attribute
<CODE>e</CODE> equals <CODE>1</CODE>, the function returns value
<CODE>1</CODE>, otherwise it returns <CODE>not 1</CODE>. Both are returned as values, not plain strings of attribute
<CODE>e2</CODE>. Finally, we tell <CODE>e2</CODE> to use
<CODE>checkE</CODE> to compute its value when needed, by
assigning <CODE>checkE</CODE> to <CODE>getValueFrom</CODE>.</P>

<P>In most circumstances, value of <CODE>e2</CODE> can be computed on the fly - we can pretend that the attribute exists in the <CODE>data</CODE>, although it doesn't (but can be computed from it). For instance, we can observe the conditional distribution of classes with regard to <CODE>e2</CODE>.</P>

<XMP class="code">>>> dist = orange.Distribution(e2, data)
>>> print dist
<324.000, 108.000>
>>>
>>> cont = orange.ContingencyAttrClass(e2, data)
>>> print "Class distribution when e=1:", cont["1"]
Class distribution when e=1: <0.000, 108.000>
>>> print "Class distribution when e<>1:", cont["not 1"]
Class distribution when e<>1: <216.000, 108.000>
</XMP>

<P><CODE>orange.Distribution</CODE> is called to compute the distribution for <CODE>e2</CODE> in <CODE>data</CODE>. When it notices that <CODE>data.domain</CODE> does not contain <CODE>e2</CODE>, it checks whether <CODE>e2</CODE>'s <CODE>getValueFrom</CODE> is defined and, seeing that it is, utilizes it to get <CODE>e2</CODE>'s values.</P>

<P>We describe technical details to make you aware that automatic recomputation requires some effort on the side of <CODE>orange.ContingencyAttrClass</CODE>. There are methods which will not do that for you, either because it would be too complex or time consuming. An example of such situation is constructive induction by function decomposition; making incompatibility matrices with attributes computed on the fly would be slow and impractical, so attempting it would yield an error. In such cases, you can simply convert entire examples table to a new domain that also includes the new attribute.</P>

<p class="header">part of <a href="variable.py">variable.py</a>
(uses <a href="monk1.tab">monk1.tab</a>)</p>
<XMP class="code">newDomain = orange.Domain([data.domain["a"], data.domain["b"],
                           e2, data.domain.classVar])
newData = orange.ExampleTable(newDomain, data)
</XMP>
</P>

<P>Automatic computation is useful when the data is split onto training and testing examples. Training examples can be modified by adding, removing and transforming attributes (in a typical setup, continuous attributes are discretized prior to learning, therefore the original attributes are replaced by new attributes), while testing examples are left as they are. When they are classified, the classifier automatically converts the testing examples into the new domain, which includes recomputation of transformed attributes. With our toy script, we can split the data, use it for learning and then test the classification of unmodified test examples.</P>

<p class="header"><a href="variable2.py">variable2.py</a>
(uses <a href="monk1.tab">monk1.tab</a>)</p>
<XMP class="code">import orange, orngTree

data = orange.ExampleTable("monk1")

indices = orange.MakeRandomIndices2(data, p0=0.7)
trainData = data.select(indices, 0)
testData = data.select(indices, 1)

e2 = orange.EnumVariable("e2", values = ["not 1", "1"])
e2.getValueFrom = lambda example, returnWhat: orange.Value(e2, example["e"]=="1")

newDomain = orange.Domain([data.domain["a"], data.domain["b"], e2, data.domain.classVar])
newTrain = orange.ExampleTable(newDomain, trainData)

tree = orange.TreeLearner(newTrain)

orngTree.printTxt(tree)

for ex in testData[:10]:
    print ex.getclass(), tree(ex)
</XMP>
</P>

<P>First, note that we have rewritten the above example,
replacing the <CODE>checkE</CODE> function with a simpler
<CODE>lambda function</CODE>, which exploits the fact that
Python's <CODE>false</CODE> and <CODE>true</CODE> equal 0 and 1.
We have split the <CODE>data</CODE> into <CODE>trainData</CODE>
and <CODE>testData</CODE>, with 70% and 30% of examples,
respectively. After constructing a new domain, we only translate
the training examples and induce a decision tree. Printout shows
that it first split the examples by the attribute <CODE>e2</CODE>
and then, if <CODE>e2</CODE> is not 1, it (implicitly) checks the
equality of <CODE>a</CODE> and <CODE>b</CODE>. In the
<CODE>for</CODE> loop, examples from <CODE>testData</CODE>, which
does not have attribute <CODE>e2</CODE> are correctly classified.
The way this is done is same for all classifiers: classifier
stores the domain description for the learning examples (or, to
be more precise, a domain in which the model is described). Prior
to classification, examples from other domains are converted to
the stored domain. In our case, examples from
<CODE>testData</CODE> are converted to <CODE>newDomain</CODE>,
and the given lambda function is used to compute the value from
<CODE>e2</CODE> from <CODE>e</CODE>.</P>

<P>What to do if an attribute can be computed from different
domains, using different procedures? Can there be more than one
function to be tried? Why is there only one
<CODE>getValueFrom</CODE>, not a list of them? Although we are
pretty advanced Orange users, we never ran into a situation where
we needed this (obviously; if needed it, we'd have done something
about it :). If you, however, need to specify more than one
function for attribute value computation, you can define a Python
class that stores a list of functions and calls them in
appropriate manner. Then give an object of this class to
<CODE>getValueFrom</CODE>. And tell us about your case, and we
shall rethink our position.</P>

</BODY>
