% file:         vlfeat.tex
% description:  An introduction to the VisionLab Features Library
% author:       Andrea Vedaldi

%\documentclass[9.5pt,journal,final,finalsubmission]{IEEEtran}
\documentclass[9.5pt]{article}
\usepackage{times}
\usepackage[margin=1cm]{geometry}


\usepackage{graphicx,amsmath,amssymb,color}

\usepackage{subfig}
\usepackage{xspace}
\usepackage{ifpdf}
%\usepackage{visionlab}

\ifpdf
\DeclareGraphicsExtensions{.pdf,.eps,.png}
\usepackage{epstopdf}
\else
\DeclareGraphicsExtensions{.png,.eps,.pdf}
\fi

\newcommand{\VLFeat}{{\sc VLFeat}\xspace}
\newcommand{\block}{\vspace{.5em}\noindent}
\newcommand{\cmd}  [1]{{\color{red}\tt   #1}}
\newcommand{\param}[1]{{\color{red}\tt   #1}}
\newcommand{\real}{\ensuremath{\mathbb{R}}}
\title{An Introduction to the\\ VisionLab Features Library} 
\author{A. Vedaldi, B. Fulkerson}

% --------------------------------------------------------------------
\begin{document}
% --------------------------------------------------------------------

\ifpdf\twocolumn\fi
\maketitle{}
\ifpdf\tableofcontents{}\fi

% --------------------------------------------------------------------
\section{Introduction}\label{intro}
% --------------------------------------------------------------------

\VLFeat (VisionLab Features Library) is a collection of computer
vision algorithms with a special focus on image features such as 
SIFT and MSER. The most important algorithms are implemented
in a lightweight and portable C (C-90) library (this library is documented
elsewhere and not covered by this article) and are made
accessible through the library API, command line programs, and MATLAB programs.

This article is an introduction and a tutorial to
\VLFeat. Here we focus on the MATLAB interface to \VLFeat, as the most simple and useful one, and we mention briefly the command line interface. There are tree pieces of documentation
for \VLFeat:
\begin{itemize}\raggedright
\item The built-in help of the MATLAB programs (\verb$help <PROGRAM>$).
\item The Unix MAN pages of the command line programs (\verb$man <PROGRAM>$).
\item The documentation of the core C library \cite{}.
\end{itemize}
The documentation of the C library is very useful even if only the MATLAB or command line interfaces are used because it contains the authoritative descriptions of the main algorithms.

% --------------------------------------------------------------------
\section{SIFT}\label{sift}
% --------------------------------------------------------------------

The {\em Scale-Invariant Feature Transform (SIFT)}~\cite{lowe04distinctive} bundles a feature detector
and a feature descriptor. A {\em feature detecto}r takes and image $I$ and selects a number of {\em frames} (``keypoints'', ``interest points'', ``regions''), which
are stable image regions. Here ``stable'' means that the same regions
are selected up to a prescribed set of image transformations (due to noise, viewpoint changes, illumination changes and so on). A {\em feature
descriptor} computes, from the local appearance of a frame, a {\em
  descriptors}, a distinctive label that helps identify the frame.

\begin{figure*}
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_0}
\label{fig:sift-intro-a}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_2}
\label{fig:sift-intro-b}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/sift_basic_3}
\label{fig:sift-intro-c}}
\caption{{\em SIFT: frames and descriptors.} \protect\subref{fig:sift-intro-a}
  a test image, \protect\subref{fig:sift-intro-b} 50 detected features
  \protect\subref{fig:sift-intro-c} and their
  descriptors.}\label{fig:sift-intro}
\end{figure*}

Both the detector and descriptor are accessible by a single MATLAB
program called \cmd{sift} (there is a similar command line utility). To
demonstrate the usage of \cmd{sift}, we open MATLAB and we load a
test image (Fig.~\ref{fig:sift-intro-a}):
\begin{verbatim}
pfx = fullfile(vlfeat_root,'data','a.jpg') ;
I = imread(pfx) ;
image(I) ;
\end{verbatim}
The \verb$sift$ command needs a gray scale image in single
precision. It also expects the image to be normalized in the $[0,255]$
range (although this is not required, the default values of the
various thresholds used by the algorithm are tuned for this
case). This is obained by
\begin{verbatim}
I = float(rgb2gray(I)) ;
\end{verbatim}
We compute the SIFT frames (keypoints) and descriptors by
\begin{verbatim}
[f,d] = sift(I) ;
\end{verbatim}
The matrix \verb$f$ has a column for each frame with the parameters
$(x,y,\sigma,\theta)$. Here $(x,y)$ is the frame center, $\sigma$ the
frame scale (radius) and $\theta$ the frame ortientation. We visualize
a random selection of 50 features (Fig.~\ref{fig:sift-intro-b}) by:
\begin{verbatim}
perm = randperm(size(f,2)) ; 
sel  = perm(1:50) ;
h1   = plotframe(f(:,sel)) ; 
h2   = plotframe(f(:,sel)) ; 
set(h1,'color','y','linewidth',3) ;
set(h2,'color','k','linewidth',1) ;
\end{verbatim}
We can also overlay the descriptors (Fig.~\ref{fig:sift-intro-c}) by
\begin{verbatim}
h3 = plotsiftdescriptor(d(:,sel),f(:,sel)) ;  
set(h3,'color','g') ;
\end{verbatim}

% --------------------------------------------------------------------
\subsection{Detector parameters}\label{sift.parameters}
% --------------------------------------------------------------------

The SIFT detector is controlled mainly by two parameters: the peak
threshold and the (non) edge treshold. 

The {\bf peak treshold} filters peaks of the DoG scale space that are
too small (in absolute value). For instance, consider the test image
(Fig.~\ref{fig:sift-peak-tresh}) obtained as a gradient of Gaussian
blobs:
\begin{verbatim}
I = double(rand(100,500) <= .005) ;
I = (ones(100,1) * linspace(0,1,500)) .* I ;
I(:,1) = 0 ; I(:,end) = 0 ;
I(1,:) = 0 ; I(end,:) = 0 ;
I = 2*pi*4^2 * imsmooth(I,4)
I = single(255 * I) ;
\end{verbatim}
We run the detector with peak treshold \verb$x$ by
\begin{verbatim}
f = sift(I, 'peaktresh', x) ;
\end{verbatim}
obtaining less and less features (Fig.~\ref{fig:sift-peak-tresh}).

\begin{figure}
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_peak_4}
\end{center}
\caption{{\em SIFT: peak treshold.} From top to bottom: test image and
  SIFT frames detected for increasing values of the peak treshold.}
\label{fig:sift-peak-tresh}
\end{figure}

The {\bf edge trehsold} instead eliminates peaks of the DoG scale
spcae whose curvature is too small (the reason is that such peaks
yields badly localized frames). For instance, consider the test image
(Fig.~\ref{fig:sift-edge-tresh})
\begin{verbatim}
I = zeros(100,500) ;
for i=[10 20 30 40 50 60 70 80 90]
  I(50-round(i/3):50+round(i/3),i*5) = 1 ;
end
I = 2*pi*8^2 * imsmooth(I,8) ;
I = single(255 * I) ;
\end{verbatim}
We run the detector with edge treshold \verb$x$ by
\begin{verbatim}
f = sift(I, 'peaktresh', x) ;
\end{verbatim}
obtaining more and more features (Fig.~\ref{fig:sift-edge-tresh}).

\begin{figure}[h]
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/sift_edge_4}
\end{center}
\caption{{\em SIFT: edge treshold.} From top to bottom: test image and
  SIFT frames detected for increasing values of the edge
  treshold. Notice that eventually, due to the interaction of nearby
  structures, some ``negative'' blobs are selected too.}
\label{fig:sift-edge-tresh}
\end{figure}

% --------------------------------------------------------------------
\subsection{Custom frames}\label{sift.custom}
% --------------------------------------------------------------------

The MATLAB command \cmd{sift} (and the command line utility) can
bypass the detector and run the descriptor on custom frames.

%\begin{figure}
%\begin{center}
%\includegraphics[width=0.7\columnwidth]{figures/demo/sift_basic_4}
%\end{center}
%\caption{{\em SIFT: custom frames.} The descriptor computed at a
%  custom frame.}
%\label{fig:sift-custom}
%\end{figure}

For instance, we can compute the descriptor of a SIFT frame centered
at position $(x,y)=(100,100)$, of scale $\sigma=10$ and orientation
$\theta=\pi/2$ by
\begin{verbatim}
fc = [100;100;10;pi/8] ;
[f,d] = sift(I,'frames',fc) ;
\end{verbatim}
Mutiple frames \verb$fc$ an be specified as well. In this case they
are re-ordered by increasing scale.\footnote{The sorting anglorithm is
  stable, so the natural correspondence custom frames descriptors can
  be preserved by making sure to pass to the function a set of
  pre-predered frames.}


% --------------------------------------------------------------------
\subsection{Conventions}\label{sift.conventions}
% --------------------------------------------------------------------

Our implementation SIFT frames are expressed in the standard image
reference.  The only difference between the command line and MATLAB
version is that the latter assumes that the image origin (top-left
corner) has coordinate $(1,1)$ as opposed to $(0,0)$. Lowe's original
implementation uses a different reference system, so if the two implementations
are to be compared the necessary conversion needs to be performed.
The details are illustrated in Fig.~\ref{fig:sift-conv}

\begin{figure}
\begin{center}
\includegraphics[width=1.0\columnwidth]{figures/sift-conv}
\end{center}
\caption{{\em SIFT: conventions.} {\bf Top.} Our implementation uses
  the standard image reference systesm, with the $y$ axis pointing
  donward. The frame orientation $\theta$ and descriptor are expressed
  in the same reference system (i.e. a small positive rotation of $x$
  moves it towards $y$). Recall that each descriptor elment is a bin
  indexed by $(\theta,x,y)$; the histogram is vectorized in such a way
  that $\theta$ is the most quickly varying index and $y$ the
  slowest. {\bf Bottom.} Lowe's implementation uses a slightly
  different convention: frames centers are expressed relative to the
  standard image reference system, but the frame orientation and the
  descriptor assume that the $y$ axis points upward. Consequently,
  frames orientations need to be transformed ($\theta'=-\theta$) and
  descriptor elements re-arranged.}
\label{fig:sift-conv}
\end{figure}

% --------------------------------------------------------------------
\subsection{Conformity}\label{sift.conformity}
% --------------------------------------------------------------------

Our implementation produces SIFT frames and descriptors that are
almost identical to Lowe's original implementation~\cite{lowe07sift}
(Fig.~\ref{fig:sift-conformity}). Small differences are due to
numerical errors, a minor difference in the computation of the
orientation (we eliminated a small bias introduce by Lowe's original implementation). 
The most significant difference is that a minority of the frames are detected by one implementation but not the other.

\begin{figure}
\begin{center}
\subfloat[]{
\includegraphics[width=0.49\columnwidth]{figures/demo/sift_cmd_1}
\label{fig:sift-custom.a}
}\hfill
\subfloat[]{
\includegraphics[width=0.49\columnwidth]{figures/demo/sift_cmd_2}
\label{fig:sift-custom.b}
}\\
\end{center}
\caption{ {\em SIFT: comparison to Lowe's original implementation.}
  \protect\subref{fig:sift-custom.a} SIFT frames detected by our
  implementation (both through the MATLAB and command line interfaces)
  and the original Lowe's implementation: there is a very good
  correspondence (up to numerical errors).  Noice however that a few
  frames are detected by one implementation but not the other.
  \protect\subref{fig:sift-custom.b} The same for the sift descriptors of some
  of the frames: again the correspondence is very good.}
\label{fig:sift-conformity}
\end{figure}

% --------------------------------------------------------------------
\section{MSER}\label{mser}
% --------------------------------------------------------------------

{\em Maximally Stable Extremal Regions (MSER)} is a feature detector; Analogously to
the SIFT detector (see Sect.~\ref{sift}), the MSER algorithm takes and image $I$ and extracts a number of feature frames (Fig.~\ref{fig:mser-intro}). Frames are either the MSERs or ellipsoids fitted to them. An MSER is a {\em stable} connected component of some level sets $\{x:I(y)\leq\gamma\}, \gamma\in\real$ of the image $I$.

\begin{figure*}[t]
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_0}
\label{fig:mser-intro-a}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_1}
\label{fig:mser-intro-b}}
\hfill
\subfloat[]{
\includegraphics[width=0.32\textwidth]{figures/demo/mser_basic_2}
\label{fig:mser-intro-c}}
\caption{{\em MSER: frames} \protect\subref{fig:sift-intro-a}
  a test image, \protect\subref{fig:sift-intro-b} detected MSERs (positive and negative), \protect\subref{fig:sift-intro-c} MSERs as fitted ellipses.}
\label{fig:mser-intro}
\end{figure*}

A single pixel $x$ ({\em seed}) is sufficient to identify any MSER as
the connected component of the level set of intensity $\gamma=I(x)$ which contains the
pixel $x$. MSERs, as identified by {\em seeds}, have arbitrary shape (Fig.~\ref{fig:mser-intro-b}). Usually their shape is simplified by fitting ellipsoids, as exemplified in (Fig.~\ref{fig:mser-intro-c}).

To demonstrate the usage of \cmd{mser}, we open MATLAB and we load a
test image (Fig.~\ref{fig:sift-intro-a}):
\begin{verbatim}
pfx = fullfile(vlfeat_root,'data','spots.jpg') ;
I = imread(pfx) ;image(I) ; 
\end{verbatim}
We then convert the image to a format that is suitable for the \cmd{mser} command.
\begin{verbatim}
I = uint8(rgb2gray(I)) ;
\end{verbatim}
We compute the region seeds and frames by
\begin{verbatim}
[r,f] = mser(I,'MinDiversity',0.7,'MaxVariation',0.2,'Delta',10) ;
\end{verbatim}
We plot the region frames by
\begin{verbatim}
clf ; imagesc(I) ; 
hold on ;
f = ertr(f) ;
plotframe(f) ;
\end{verbatim}
The \cmd{ertr} transposes the elliptical frame and is needed because the \cmd{mser} code assumes that the row index is the first index, but the normal image convention assumes that this is the $x$ (column) index.

Plotting the MSERs themselves is a bit more involved as they have arbitrary shape.
To this end, we exploit two functions: \cmd{erfill}, which, given an image and a region seed,  returns a list of the pixels belonging to that region, and MATLAB built-in \cmd{contourn}, which draws the contour lines of a function. We start by
\begin{verbatim}
M = zeros(size(I)) ;for x=r'  s = erfill(I,x) ;  M(s) = M(s) + 1;end
\end{verbatim}
which computes a matrix \verb$M$ whose value are equal to the number of overlapping extremal
regions. Next, we use \verb$M$ and \cmd{contour} to display the region boundaries:
\begin{verbatim}
clf ; imagesc(I) ;
hold on ;
[c,h]=contour(M,(0:max(M(:)))+.5) ;
\end{verbatim}


% --------------------------------------------------------------------
\subsection{MSER parameters}\label{mser.parameters}
% --------------------------------------------------------------------

In~\cite{matas03robust}, MSERs are controlled by a single parameter $\Delta$. In practice, this implementation uses a few more parameters to refine even more the selection of the
useful extremal regions.

Understanding the parameters require to know how the stability of the
extremal regions is evaluated. The stability of an extremal region $R$ is inversely proportional to the relative area variation of $R$ when the intensity level is increased by $\Delta$. Formally, the variation is defined as $|R_{+\Delta} - R|/|R|$, where $|R|$ denotes the area of the extremal region $R$, $R_{+\Delta}$ is the extremal region $+\Delta$ levels up which contains $R$ and $R_{+\Delta} - R$ is the set difference of the two regions. If the score is small, then there is a small area variation and the region is deemed stable.

Based on the stability score, the algorithm keeps the extremal regions which are maximally stable, meaning that they have minimum variation compared to the extremal region one intensity level below and one intensity level up\footnote{Due to the discrete nature of the image, the region below/up may be coincident with the actual region, in which case the region is still deemed maximal.}. Even if an extremal region is maximally stable, it might be rejected if
\begin{itemize}
\raggedright
\item it is too big (see the parameter \verb$MaxArea$);
\item it is too small (see the parameter \verb$MinArea$);
\item it is too unstable (see the parameter \verb$MaxVariation$);
\item it is too similar to another MSER (see the paramter \verb$MinDiversity$).
\end{itemize}

The interpretation of the parameters \verb$MaxArea$ and \verb$MinArea$. The parameter \verb$MaxVariation$ removes regions that are too unstable (even if they might be maximally stable in the local). The interaction of \verb$MaxVariation$ and \verb$Detla$ is illustrated in 
Fig.~\ref{fig:mser-delta}.

\begin{figure}
\begin{center}
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_0}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_1}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_2}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_3}\\
\includegraphics[width=0.6\columnwidth]{figures/demo/mser_delta_4}
\end{center}
\caption{{\em MSER: role of the paramter $\Delta$} {\bf Top.} The intensity profile. The bumps
have heights equal to $32,64,96,128$ and $160$ intensity levels. {\bf Other rows.} The variation score of a bump is either $0$ if $\Delta$ is smaller than the bump height or very large otherwise (as the next extremal region is as big as the whole image). 
\param{MaxVariation} is set to 0.25.}
\label{fig:mser-delta}
\end{figure}

While the concept of local stability is simple to grasp, there is a complication that we did not address yet, i.e. how to define ``locality'' in the comparison of extremal regions. In a senseFor instance, one could define neighbors of an extremal region $R$ the parent extremal region $R_{+1}$ at level e would compare the region $R$ with the region $R_{+1}$ and 


% --------------------------------------------------------------------
\section{MATLAB utility programs}\label{other}
% --------------------------------------------------------------------
This is a list of other useful MATLAB programs bundled with \VLFeat:
\begin{itemize}
\item \cmd{imsmooth} smoothes an image by a Gaussian kernel (simple but very useful as it is generally much faster than MATLAB general purpose smoothing functions).
\item \cmd{plotframe} plots a variety of feature frame kinds.
\item \cmd{binsum} performs binned summations, useful as a building block for
the fast computation of histograms. \cmd{whistc} computed weighed histograms.
\item \cmd{imarray} and \cmd{imarraysc} arrange and visualize multiple images in a grid; \cmd{imsc} scales the image range; \cmd{tightsubplot} is similar to built-in \cmd{subplot}, but 
produces narrower margins.
\item \cmd{cf} copies a figure.
\item \cmd{rord} and \cmd{irodr} compute the Rodrigues' formula and its inverse.
\item \cmd{override} overrides members of a structure with members of another strucutre.
\item \cmd{imwbackward} warps an image by the inverse mapping method (generally much faster than MATLAB general purpose warping functions).
\item \cmd{waffine} computes the affine warp of a set of points. \cmd{tps}, \cmd{tpsu}, \cmd{wtps} compute the thin-plate spline warp of a set of points. \cmd{witps} computes the inverse thin plate warp of a set of point (by numerically inverting the transformation). They may me used in combination with \cmd{imwbackward}.
\item \cmd{xyz2lab}, \cmd{xyz2luv}, \cmd{xyz2rgb}, \cmd{rgb2xyz} convert color spaces.
\item \cmd{rcos}, \cmd{gaussian}, \cmd{dgaussian}, \cmd{ddgaussian} compute some basic functions.
\end{itemize}

% --------------------------------------------------------------------
\raggedright
\bibliographystyle{IEEEtran}
\bibliography{bibliography}
% --------------------------------------------------------------------

% --------------------------------------------------------------------
\end{document}
% --------------------------------------------------------------------